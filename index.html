<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>La Team</title>

<style>
:root{
  --bg1:#1f7a5a;
  --bg2:#0b3b6f;
  --accent:#ffb35c;
  --btn:#00c9a7;
  --btnText:#073;
  --card:rgba(255,255,255,0.12);
  --card2:rgba(0,0,0,0.24);
  --muted:rgba(255,255,255,0.86);
  --danger:#ff6b6b;
}
*{ box-sizing:border-box; }

body{
  margin:0;
  font-family: Arial, sans-serif;
  color:#fff;
  min-height:100vh;
  background:
    linear-gradient(135deg, rgba(31,122,90,0.35), rgba(11,59,111,0.35)),
    #0b3b6f;
}

.container{ max-width:980px; margin:auto; padding:16px; }
.hidden{ display:none; }

.card{
  background: var(--card);
  padding:16px;
  border-radius:14px;
  margin-bottom:14px;
  backdrop-filter: blur(2px);
}

h1,h2{ text-align:center; margin:10px 0; }
.small{ text-align:center; color:var(--muted); font-size:14px; }

label{ display:block; margin-top:10px; color:var(--muted); }

input, select, button{
  width:100%;
  padding:12px;
  margin-top:8px;
  border-radius:10px;
  border:none;
  font-size:16px;
}

button{
  background:var(--btn);
  color:var(--btnText);
  font-weight:800;
  cursor:pointer;
}
button.secondary{
  background:rgba(255,255,255,0.18);
  color:#fff;
}
button.danger{
  background:rgba(255,107,107,0.3);
  color:#fff;
}
button:disabled{ opacity:0.5; cursor:not-allowed; }

.row{ display:flex; gap:10px; }
.row>div{ flex:1; }

table{ width:100%; border-collapse:collapse; }
th,td{ padding:8px; text-align:center; }
th{ background:var(--card2); }

.badge{
  display:inline-block;
  padding:6px 10px;
  border-radius:999px;
  background:rgba(0,0,0,0.25);
  font-size:13px;
}

.ladderArrows{
  margin-top:6px;
  font-size:13px;
}
.ladderArrows .up{ color:#7CFF7C; font-weight:900; }
.ladderArrows .down{ color:#FF7C7C; font-weight:900; }
</style>
</head>

<body>
<div class="container">

<!-- SETUP -->
<div id="setup" class="card">
  <h2>RÃ©glages</h2>
  <div class="small">Choisis le format puis dÃ©marre</div>

  <label>Nombre de joueurs</label>
  <select id="playerCount">
    <option value="4">4</option>
    <option value="6">6</option>
    <option value="8" selected>8</option>
    <option value="12">12</option>
    <option value="16">16</option>
  </select>

  <label>Mode de jeu</label>
  <select id="gameMode">
    <option value="americano">Americano</option>
    <option value="ladder">MontÃ©e / Descente</option>
  </select>

  <label>Points du match (total)</label>
  <input id="maxPoints" type="number" min="1" max="31" value="21">

  <div id="players"></div>

  <div class="row">
    <div><button onclick="startNewTournament()">DÃ©marrer</button></div>
  </div>
</div>

<!-- GAME -->
<div id="game" class="hidden">
  <div class="card">
    <h2>Matchs</h2>
    <div id="progressText" class="small"></div>
    <div id="courts"></div>

    <div class="row">
      <div><button id="undoBtn" class="secondary" onclick="undoLast()" disabled>â†©ï¸Ž Retour</button></div>
      <div><button id="nextBtn" onclick="nextMatch()" disabled>Round suivant</button></div>
    </div>
  </div>

  <div class="card">
    <h2>Classement</h2>
    <table>
      <thead>
        <tr>
          <th>Joueur</th>
          <th>MJ</th>
          <th>V</th>
          <th>+</th>
          <th>-</th>
          <th>Diff</th>
        </tr>
      </thead>
      <tbody id="ranking"></tbody>
    </table>
  </div>
</div>

<script>
/* ===================== STATE ===================== */
let state = {
  mode: "americano",
  n: 0,
  maxPoints: 21,
  totalRounds: 0,

  players: [],
  schedule: [],
  matchIndex: 0,

  validatedCourts: [],
  courtScores: [],
  results: [],
  history: [],

  ladderOpp: null
};

/* ===================== HELPERS ===================== */
function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}
function playerName(i){ return state.players[i].name; }

/* ===================== SETUP ===================== */
const setupEl=document.getElementById("setup");
const gameEl=document.getElementById("game");
const playersDiv=document.getElementById("players");
const courtsDiv=document.getElementById("courts");
const rankingBody=document.getElementById("ranking");
const progressText=document.getElementById("progressText");
const undoBtn=document.getElementById("undoBtn");
const nextBtn=document.getElementById("nextBtn");

function createInputs(){
  playersDiv.innerHTML="";
  const n=+document.getElementById("playerCount").value;
  for(let i=0;i<n;i++){
    playersDiv.innerHTML+=`<input placeholder="Joueur ${i+1}" id="p${i}">`;
  }
}
document.getElementById("playerCount").addEventListener("change",createInputs);
createInputs();
/* ===================== SCHEDULING ===================== */
function buildScheduleAmericano(n){
  const rounds=[];
  const players=[...Array(n).keys()];
  for(let r=0;r<n-1;r++){
    shuffle(players);
    const courts=[];
    for(let i=0;i<n;i+=4){
      if(players[i+3]===undefined) break;
      courts.push({
        teamA:[players[i],players[i+1]],
        teamB:[players[i+2],players[i+3]]
      });
    }
    rounds.push({rest:[],courts});
  }
  return rounds;
}

function buildFirstRoundLadder(n){
  const idx=[...Array(n).keys()];
  shuffle(idx);
  const courts=[];
  for(let i=0;i<n;i+=4){
    courts.push({
      teamA:[idx[i],idx[i+1]],
      teamB:[idx[i+2],idx[i+3]]
    });
  }
  return {rest:[],courts};
}

function ladderOppScore(teamA,teamB){
  if(!state.ladderOpp) return 0;
  let s=0;
  for(const a of teamA) for(const b of teamB) s+=state.ladderOpp[a][b];
  return s;
}

function buildNextRoundLadder(prevCourts,prevResults){
  const moved=[];
  for(let i=0;i<prevCourts.length;i++){
    const court=prevCourts[i];
    const res=prevResults[i];
    const win=res.a>res.b?court.teamA:court.teamB;
    const lose=res.a>res.b?court.teamB:court.teamA;
    moved.push({win,lose});
  }

  const newCourts=[];
  for(let i=0;i<moved.length;i++){
    const t1=moved[i].win;
    const t2=moved[i].lose;

    const opt1A=[t1[0],t2[0]];
    const opt1B=[t1[1],t2[1]];
    const opt2A=[t1[0],t2[1]];
    const opt2B=[t1[1],t2[0]];

    const s1=ladderOppScore(opt1A,opt1B);
    const s2=ladderOppScore(opt2A,opt2B);

    if(s1<=s2) newCourts.push({teamA:opt1A,teamB:opt1B});
    else newCourts.push({teamA:opt2A,teamB:opt2B});
  }
  return {rest:[],courts:newCourts};
}

/* ===================== GAME FLOW ===================== */
function startNewTournament(){
  state.mode=document.getElementById("gameMode").value;
  state.n=+document.getElementById("playerCount").value;
  state.maxPoints=+document.getElementById("maxPoints").value;
  state.players=[];
  for(let i=0;i<state.n;i++){
    const name=document.getElementById("p"+i).value||("J"+(i+1));
    state.players.push({name,mj:0,v:0,plus:0,minus:0});
  }
  state.totalRounds=state.n-1;
  state.matchIndex=0;
  state.history=[];
  state.results=[];
  state.ladderOpp=state.mode==="ladder"
    ?Array.from({length:state.n},()=>Array(state.n).fill(0))
    :null;

  if(state.mode==="ladder"){
    state.schedule=[buildFirstRoundLadder(state.n)];
  }else{
    state.schedule=buildScheduleAmericano(state.n);
  }

  setupEl.classList.add("hidden");
  gameEl.classList.remove("hidden");
  renderMatch();
  renderRanking();
}

function renderMatch(){
  const round=state.schedule[state.matchIndex];
  progressText.textContent=`Round ${state.matchIndex+1} / ${state.totalRounds}`;
  courtsDiv.innerHTML="";
  state.validatedCourts=Array(round.courts.length).fill(false);
  state.courtScores=Array(round.courts.length).fill(null)
    .map(()=>({a:0,b:state.maxPoints}));

  round.courts.forEach((c,i)=>{
    courtsDiv.innerHTML+=`
      <div class="card">
        <b>${playerName(c.teamA[0])}/${playerName(c.teamA[1])}</b>
        vs
        <b>${playerName(c.teamB[0])}/${playerName(c.teamB[1])}</b>

        <div class="row">
          <div>
            <select id="a${i}" onchange="scoreChange(${i},'a')">
              ${scoreOptions()}
            </select>
          </div>
          <div>
            <select id="b${i}" onchange="scoreChange(${i},'b')">
              ${scoreOptions()}
            </select>
          </div>
        </div>

        <button onclick="validateCourt(${i})">Valider</button>
        <div id="arrows${i}" class="ladderArrows"></div>
      </div>`;
  });

  undoBtn.disabled=true;
  nextBtn.disabled=true;
}

function scoreOptions(){
  let s="";
  for(let i=0;i<=state.maxPoints;i++) s+=`<option>${i}</option>`;
  return s;
}

function scoreChange(i,side){
  const a=document.getElementById("a"+i);
  const b=document.getElementById("b"+i);
  let va=+a.value,vb=+b.value;
  if(side==="a") vb=state.maxPoints-va;
  else va=state.maxPoints-vb;
  a.value=va; b.value=vb;
  state.courtScores[i]={a:va,b:vb};
}

function validateCourt(i){
  if(state.validatedCourts[i]) return;
  const round=state.schedule[state.matchIndex];
  const court=round.courts[i];
  const {a,b}=state.courtScores[i];
  if(a===b){ alert("Ã‰galitÃ© interdite"); return; }

  state.history.push(JSON.stringify(state));

  applyResult(court.teamA,court.teamB,a,b);
  state.results[state.matchIndex]=state.results[state.matchIndex]||[];
  state.results[state.matchIndex][i]={a,b};

  if(state.mode==="ladder"){
    const win=a>b?court.teamA:court.teamB;
    const lose=a>b?court.teamB:court.teamA;
    for(const x of win) for(const y of lose){
      state.ladderOpp[x][y]++; state.ladderOpp[y][x]++;
    }
    document.getElementById("arrows"+i).innerHTML=
      `<span class="up">â†‘</span> ${playerName(win[0])}/${playerName(win[1])}
       <span class="down">â†“</span> ${playerName(lose[0])}/${playerName(lose[1])}`;
  }

  state.validatedCourts[i]=true;
  nextBtn.disabled=!state.validatedCourts.every(Boolean);
  undoBtn.disabled=false;
  renderRanking();
}

function applyResult(teamA,teamB,a,b){
  for(const p of teamA){
    state.players[p].mj++;
    state.players[p].plus+=a;
    state.players[p].minus+=b;
  }
  for(const p of teamB){
    state.players[p].mj++;
    state.players[p].plus+=b;
    state.players[p].minus+=a;
  }
  (a>b?teamA:teamB).forEach(p=>state.players[p].v++);
}
/* ===================== NEXT / UNDO ===================== */
function nextMatch(){
  if(!state.validatedCourts.every(Boolean)) return;

  // ladder: prÃ©pare le round suivant (en cassant les Ã©quipes + en Ã©vitant re-adversaires)
  if(state.mode==="ladder" && state.matchIndex+1 < state.totalRounds){
    const prevRound = state.schedule[state.matchIndex];
    const prevRes   = state.results[state.matchIndex] || [];
    state.schedule[state.matchIndex+1] = buildNextRoundLadder(prevRound.courts, prevRes);
  }

  state.matchIndex++;

  if(state.matchIndex >= state.totalRounds){
    // fin tournoi
    gameEl.classList.add("hidden");
    finishEl.classList.remove("hidden");
    renderFinish();
    return;
  }

  renderMatch();
}

function undoLast(){
  if(!state.history.length) return;
  // on restaure tout lâ€™Ã©tat
  state = JSON.parse(state.history.pop());

  // rÃ©-affiche Ã©cran game
  setupEl.classList.add("hidden");
  finishEl.classList.add("hidden");
  gameEl.classList.remove("hidden");

  // re-render
  renderMatchAfterRestore();
  renderRanking();
}

function renderMatchAfterRestore(){
  // Re-rendu du round courant AVEC les scores + validations dÃ©jÃ  faites
  const round=state.schedule[state.matchIndex];
  progressText.textContent=`Round ${state.matchIndex+1} / ${state.totalRounds}`;
  courtsDiv.innerHTML="";

  // si jamais ces tableaux nâ€™existent pas
  if(!Array.isArray(state.validatedCourts) || state.validatedCourts.length!==round.courts.length){
    state.validatedCourts = Array(round.courts.length).fill(false);
  }
  if(!Array.isArray(state.courtScores) || state.courtScores.length!==round.courts.length){
    state.courtScores = Array(round.courts.length).fill(null).map(()=>({a:0,b:state.maxPoints}));
  }

  round.courts.forEach((c,i)=>{
    const disabled = !!state.validatedCourts[i];
    courtsDiv.innerHTML+=`
      <div class="card">
        <b>${playerName(c.teamA[0])}/${playerName(c.teamA[1])}</b>
        vs
        <b>${playerName(c.teamB[0])}/${playerName(c.teamB[1])}</b>

        <div class="row">
          <div>
            <select id="a${i}" ${disabled?"disabled":""} onchange="scoreChange(${i},'a')">
              ${scoreOptions()}
            </select>
          </div>
          <div>
            <select id="b${i}" ${disabled?"disabled":""} onchange="scoreChange(${i},'b')">
              ${scoreOptions()}
            </select>
          </div>
        </div>

        <button ${disabled?"disabled":""} onclick="validateCourt(${i})">Valider</button>
        <div id="arrows${i}" class="ladderArrows"></div>
      </div>`;
  });

  // rÃ©-apply scores mÃ©morisÃ©s
  round.courts.forEach((_,i)=>{
    const a=document.getElementById("a"+i);
    const b=document.getElementById("b"+i);
    if(!a||!b) return;
    const mem = state.courtScores[i] || {a:0,b:state.maxPoints};
    a.value = String(mem.a);
    b.value = String(mem.b);

    // si câ€™Ã©tait dÃ©jÃ  validÃ©, on rÃ©-affiche les flÃ¨ches si ladder
    if(state.mode==="ladder" && state.validatedCourts[i]){
      const res = (state.results?.[state.matchIndex]?.[i]);
      if(res){
        const court = round.courts[i];
        const win = res.a>res.b ? court.teamA : court.teamB;
        const lose= res.a>res.b ? court.teamB : court.teamA;
        const el=document.getElementById("arrows"+i);
        if(el){
          el.innerHTML=
            `<span class="up">â†‘</span> ${playerName(win[0])}/${playerName(win[1])}
             <span class="down">â†“</span> ${playerName(lose[0])}/${playerName(lose[1])}`;
        }
      }
    }
  });

  nextBtn.disabled=!state.validatedCourts.every(Boolean);
  undoBtn.disabled=(state.history.length===0);
}

/* ===================== RANKING ===================== */
function playerName(i){ return state.players[i]?.name || ("J"+(i+1)); }

function renderRanking(){
  rankingBody.innerHTML="";
  const sorted=[...state.players].sort((p1,p2)=>{
    const d1=p1.plus-p1.minus;
    const d2=p2.plus-p2.minus;
    if(p2.v!==p1.v) return p2.v-p1.v;
    if(d2!==d1) return d2-d1;
    return p2.plus-p1.plus;
  });

  sorted.forEach(p=>{
    rankingBody.innerHTML+=`
      <tr>
        <td>${p.name}</td>
        <td>${p.mj}</td>
        <td>${p.v}</td>
        <td>${p.plus}</td>
        <td>${p.minus}</td>
        <td>${p.plus-p.minus}</td>
      </tr>`;
  });
}

/* ===================== FINISH SCREEN ===================== */
function renderFinish(){
  finalRankingBody.innerHTML="";
  const sorted=[...state.players].sort((p1,p2)=>{
    const d1=p1.plus-p1.minus;
    const d2=p2.plus-p2.minus;
    if(p2.v!==p1.v) return p2.v-p1.v;
    if(d2!==d1) return d2-d1;
    return p2.plus-p1.plus;
  });

  sorted.forEach((p,i)=>{
    finalRankingBody.innerHTML+=`
      <tr>
        <td>${i+1}</td>
        <td>${p.name}</td>
        <td>${p.mj}</td>
        <td>${p.v}</td>
        <td>${p.plus}</td>
        <td>${p.minus}</td>
        <td>${p.plus-p.minus}</td>
      </tr>`;
  });

  // recap
  let html="";
  for(let r=0;r<(state.results?.length||0);r++){
    const round=state.schedule[r];
    const resArr=state.results[r]||[];
    if(!round) continue;
    for(let c=0;c<round.courts.length;c++){
      const res=resArr[c];
      if(!res) continue;
      const court=round.courts[c];
      html+=`
        <div class="recapLine">
          <div class="recapLeft">
            <b>R${r+1}</b> â€¢ T${c+1} â€”
            ${playerName(court.teamA[0])}/${playerName(court.teamA[1])}
            <b>${res.a}-${res.b}</b>
            ${playerName(court.teamB[0])}/${playerName(court.teamB[1])}
          </div>
          <div class="recapRight">${state.mode==="ladder" ? "â†‘â†“" : "ðŸŽ¾"}</div>
        </div>`;
    }
  }
  finalRecap.innerHTML = html || `<div class="small">Aucun match validÃ©.</div>`;
}

/* ===================== SETUP HELPERS ===================== */
function createInputs(){
  playersDiv.innerHTML="";
  const n=+playerCountEl.value;
  for(let i=0;i<n;i++){
    playersDiv.innerHTML+=`<input id="p${i}" placeholder="Joueur ${i+1}">`;
  }
}
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}

/* ===================== INIT ===================== */
playerCountEl.addEventListener("change", createInputs);

// boutons
undoBtn.onclick = undoLast;
nextBtn.onclick = nextMatch;

(function init(){
  createInputs();
  showSetup(); // on dÃ©marre sur rÃ©glages
})();
</script>
</body>
</html>
