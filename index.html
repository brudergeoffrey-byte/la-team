<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>La Team</title>

<style>
:root{
  --bg1:#1f7a5a;
  --bg2:#0b3b6f;
  --accent:#ffb35c;
  --btn:#00c9a7;
  --btnText:#073;
  --card:rgba(255,255,255,0.12);
  --card2:rgba(0,0,0,0.24);
  --muted:rgba(255,255,255,0.86);
  --danger:#ff6b6b;
}

*{ box-sizing:border-box; }

body{
  margin:0;
  font-family: Arial, sans-serif;
  color:#fff;
  min-height:100vh;

  background:
    linear-gradient(135deg, rgba(31,122,90,0.30), rgba(11,59,111,0.30)),
    url("./bg.jpg?v=9"),
    url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 1200'>\
<defs>\
  <radialGradient id='g' cx='50%25' cy='45%25' r='60%25'>\
    <stop offset='0%25' stop-color='white' stop-opacity='0.09'/>\
    <stop offset='100%25' stop-color='white' stop-opacity='0'/>\
  </radialGradient>\
</defs>\
<rect width='1200' height='1200' fill='none'/>\
<circle cx='560' cy='520' r='520' fill='url(%23g)'/>\
<rect x='160' y='220' width='880' height='760' rx='26' fill='none' stroke='white' stroke-opacity='0.06' stroke-width='18'/>\
<line x1='600' y1='220' x2='600' y2='980' stroke='white' stroke-opacity='0.05' stroke-width='12'/>\
<line x1='160' y1='600' x2='1040' y2='600' stroke='white' stroke-opacity='0.05' stroke-width='12'/>\
<ellipse cx='860' cy='380' rx='130' ry='170' fill='none' stroke='white' stroke-opacity='0.08' stroke-width='18'/>\
<circle cx='820' cy='330' r='14' fill='white' fill-opacity='0.06'/>\
<circle cx='860' cy='330' r='14' fill='white' fill-opacity='0.06'/>\
<circle cx='900' cy='330' r='14' fill='white' fill-opacity='0.06'/>\
<circle cx='820' cy='380' r='14' fill='white' fill-opacity='0.06'/>\
<circle cx='860' cy='380' r='14' fill='white' fill-opacity='0.06'/>\
<circle cx='900' cy='380' r='14' fill='white' fill-opacity='0.06'/>\
<circle cx='840' cy='430' r='14' fill='white' fill-opacity='0.06'/>\
<circle cx='880' cy='430' r='14' fill='white' fill-opacity='0.06'/>\
<rect x='825' y='520' width='70' height='170' rx='35' fill='none' stroke='white' stroke-opacity='0.07' stroke-width='16'/>\
</svg>");
  background-size: cover;
  background-position: center;
  background-attachment: fixed;
}

.container{ max-width: 980px; margin:auto; padding: 16px; }
h1,h2{ text-align:center; margin:10px 0 14px; }
.small{ text-align:center; color: var(--muted); margin-top:-6px; margin-bottom:10px; font-size:14px; }

.card{
  background: var(--card);
  padding: 16px;
  border-radius: 14px;
  margin-bottom: 14px;
  backdrop-filter: blur(2px);
}

label{ display:block; margin-top:10px; color:var(--muted); font-size:14px; }

input, select, button{
  width:100%;
  padding:12px;
  margin-top:8px;
  border-radius:10px;
  border:none;
  font-size:16px;
}

button{
  background: var(--btn);
  color: var(--btnText);
  font-weight: 800;
  cursor: pointer;
}
button.secondary{
  background: rgba(255,255,255,0.16);
  color:#fff;
}
button.danger{
  background: rgba(255,107,107,0.24);
  color:#fff;
}
button:disabled{ opacity:0.5; cursor:not-allowed; }

.row{ display:flex; gap:10px; }
.row>div{ flex:1; }

.hidden{ display:none; }

table{ width:100%; border-collapse:collapse; }
th,td{ padding:8px; text-align:center; }
th{ background: var(--card2); }

.badge{
  display:inline-block;
  padding:6px 10px;
  border-radius:999px;
  background:rgba(0,0,0,0.18);
  font-size:13px;
  color:var(--muted);
}
hr.sep{ border:none; height:1px; background:rgba(255,255,255,0.14); margin:12px 0; }

.topbar{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:10px;
}
.brand{
  font-weight:900;
  font-size:22px;
  display:flex;
  align-items:center;
  gap:10px;
}
.brand .dot{
  width:10px; height:10px; border-radius:50%;
  background: var(--accent);
  box-shadow: 0 0 0 6px rgba(255,179,92,0.18);
}
.topbar .actions{
  display:flex; gap:10px; align-items:center; flex-wrap:wrap;
  justify-content:flex-end;
}
.topbar button{ width:auto; padding:10px 12px; border-radius:12px; }

@media (max-width:520px){
  .topbar{ align-items:flex-start; }
  .topbar .actions button{ padding:9px 10px; font-size:14px; }
}

/* Petit bloc sauvegardes */
.savesBox{
  background: rgba(0,0,0,0.10);
  border-radius: 12px;
  padding: 12px;
  margin-top: 12px;
}

/* Recap */
.recapLine{
  display:flex;
  justify-content:space-between;
  gap:10px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(0,0,0,0.12);
  margin:6px 0;
  font-size:14px;
}
.recapLeft{ color:#fff; }
.recapRight{ color:var(--muted); text-align:right; }

/* Ladder arrows */
.ladderArrows{
  text-align:left;
  margin-top:6px;
  font-size:13px;
  color:var(--muted);
}
.ladderArrows .up{ color:#7CFF7C; font-weight:900; }
.ladderArrows .down{ color:#FF7C7C; font-weight:900; }
</style>
</head>

<body>
<div class="container">

  <div class="topbar">
    <div class="brand"><span class="dot"></span> La Team</div>
    <div class="actions">
      <!-- ‚úÖ Sauver = √©crase la sauvegarde en cours -->
      <button class="secondary" onclick="manualSaveAs()">üíæ Sauver</button>
      <button class="secondary" onclick="openLoadDialog()">üìÇ Charger</button>
      <button class="secondary" onclick="goToSetup(true)">‚öôÔ∏è Menu</button>
      <button class="danger" onclick="resetAll()">üßπ Effacer</button>
    </div>
  </div>

  <!-- SETUP -->
  <div id="setup" class="card">
    <h2>R√©glages</h2>
    <div class="small">Choisis le format puis d√©marre. (Tu peux revenir ici √† tout moment.)</div>

    <label>Nombre de joueurs</label>
    <select id="playerCount">
      <option value="4">4 joueurs</option>
      <option value="6">6 joueurs</option>
      <option value="8">8 joueurs</option>
      <option value="12">12 joueurs</option>
      <option value="16">16 joueurs</option>
    </select>

    <div id="courtWrap" style="margin-top:10px; display:none;">
      <label>Nombre de terrains</label>
      <select id="courtCount"></select>
      <div class="small" style="text-align:left; margin-top:6px;">
        Si tu choisis moins de terrains que le maximum, certains joueurs seront automatiquement au repos (Americano).
      </div>
    </div>

    <label>Mode de jeu</label>
    <select id="gameMode">
      <option value="americano" selected>Americano (rotation)</option>
      <option value="ladder">Mont√©e / Descente (gagnants montent)</option>
    </select>
    <div class="small" style="text-align:left; margin-top:6px;">
      Mont√©e/Descente recommand√© √† partir de 2 terrains et sans repos (4√óterrains joueurs).
    </div>

    <div id="players"></div>

    <label>Points du match (total)</label>
    <input id="maxPoints" type="number" min="1" max="31" step="1" value="21" />

    <div class="row">
      <div><button onclick="startNewTournament()">D√©marrer</button></div>
      <div><button class="secondary" onclick="openLoadDialog()">üìÇ Charger</button></div>
    </div>

    <div class="savesBox">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
        <div><b>Sauvegardes</b> <span class="badge" id="saveCountBadge">0</span></div>
        <button class="secondary" style="width:auto; padding:8px 10px;" onclick="refreshSavesUI()">‚Üª</button>
      </div>

      <label style="margin-top:10px;">Choisir une sauvegarde</label>
      <select id="saveSelect"></select>

      <div class="row" style="margin-top:8px;">
        <div><button class="secondary" onclick="loadSelectedSave()">Charger</button></div>
        <div><button class="danger" onclick="deleteSelectedSave()">Supprimer</button></div>
      </div>

      <div class="small" id="saveHint" style="margin-top:10px;"></div>
    </div>
  </div>

  <!-- GAME -->
  <div id="game" class="hidden">
    <div class="card">
      <h2>Matchs</h2>
      <div class="small" id="progressText"></div>
      <div class="small" id="restText"></div>

      <div id="courts"></div>

      <div class="row">
        <div><button id="undoBtn" class="secondary" onclick="undoLast()" disabled>‚Ü©Ô∏é Retour</button></div>
        <div><button id="nextBtn" onclick="nextMatch()" disabled>Round suivant</button></div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div><button class="secondary" onclick="toggleRecap()">üìú R√©cap</button></div>
        <!-- ‚úÖ Sauver = √©crase la sauvegarde en cours -->
        <div><button class="secondary" onclick="manualSaveAs()">üíæ Sauver</button></div>
      </div>

      <div id="recapInGame" class="hidden" style="margin-top:10px;"></div>
      <div class="small" id="autosaveText" style="margin-top:10px;"></div>
    </div>

    <div class="card">
      <h2>Classement</h2>
      <table>
        <thead>
          <tr>
            <th>Joueur</th>
            <th>MJ</th>
            <th>V</th>
            <th>+</th>
            <th>-</th>
            <th>Diff</th>
          </tr>
        </thead>
        <tbody id="ranking"></tbody>
      </table>
    </div>
  </div>

  <!-- FINISH -->
  <div id="finish" class="hidden">
    <div class="card">
      <h2>‚úÖ Fini !</h2>
      <div class="small">Classement final</div>

      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Joueur</th>
            <th>MJ</th>
            <th>V</th>
            <th>+</th>
            <th>-</th>
            <th>Diff</th>
          </tr>
        </thead>
        <tbody id="finalRanking"></tbody>
      </table>

      <hr class="sep">

      <h2 style="margin-top:0;">üìú R√©capitulatif des matchs</h2>
      <div class="small">Tous les rounds et scores</div>
      <div id="finalRecap"></div>

      <hr class="sep">

      <button onclick="restartSamePlayers()">üîÅ Rejouer (m√™mes joueurs)</button>

      <hr class="sep">

      <div class="row">
        <div><button class="secondary" onclick="manualSaveAs()">üíæ Sauver</button></div>
        <div><button class="secondary" onclick="openLoadDialog()">üìÇ Charger</button></div>
      </div>

      <hr class="sep">

      <label>Nouvelle partie : nombre de joueurs</label>
      <select id="finishPlayerCount">
        <option value="4">4 joueurs</option>
        <option value="6">6 joueurs</option>
        <option value="8">8 joueurs</option>
        <option value="12">12 joueurs</option>
        <option value="16">16 joueurs</option>
      </select>

      <div id="finishCourtWrap" style="display:none;">
        <label>Nombre de terrains</label>
        <select id="finishCourtCount"></select>
      </div>

      <label>Mode de jeu</label>
      <select id="finishGameMode">
        <option value="americano" selected>Americano (rotation)</option>
        <option value="ladder">Mont√©e / Descente</option>
      </select>

      <label>Points du match (total)</label>
      <input id="finishMaxPoints" type="number" min="1" max="31" step="1" value="21" />

      <button class="secondary" onclick="newGameChoosePlayers()">Nouvelle partie (changer le format)</button>
    </div>
  </div>

</div>

<script>
/* -------------------- STATE -------------------- */
let state = {
  mode: "americano",     // "americano" | "ladder"
  n: 4,
  courts: 1,
  maxPoints: 21,         // TOTAL points (ex: 21 -> 10/11)
  totalRounds: 0,

  players: [],
  schedule: [],          // rounds: {rest:[], courts:[{teamA:[i,j],teamB:[k,l]}]}
  matchIndex: 0,

  validatedCourts: [],
  courtScores: [],       // [{a,b}, ...] for current round (kept visible even validated)
  results: [],           // results[round][court] = {a,b} (for recap)

  history: [],
  savedAt: null,

  // Ladder opposition memory (√©viter re-match adversaires)
  ladderOpp: null,

  // ‚úÖ NEW: sauvegarde active (pour √©craser automatiquement)
  activeSaveId: null
};

/* Multi-sauvegardes */
const SAVES_INDEX_KEY = "la-team-saves-index-v1";
const SAVE_PREFIX     = "la-team-save-v1:";
const AUTOSAVE_KEY    = "la-team-autosave-v1";
const ACTIVE_SAVE_KEY = "la-team-active-save-id-v1";

/* -------------------- DOM -------------------- */
const setupEl = document.getElementById("setup");
const gameEl = document.getElementById("game");
const finishEl = document.getElementById("finish");

const playerCountEl = document.getElementById("playerCount");
const playersDiv = document.getElementById("players");
const maxPointsEl = document.getElementById("maxPoints");
const gameModeEl = document.getElementById("gameMode");

const courtWrap = document.getElementById("courtWrap");
const courtCountEl = document.getElementById("courtCount");

const courtsDiv = document.getElementById("courts");
const rankingBody = document.getElementById("ranking");
const finalRankingBody = document.getElementById("finalRanking");

const undoBtn = document.getElementById("undoBtn");
const nextBtn = document.getElementById("nextBtn");
const progressText = document.getElementById("progressText");
const restText = document.getElementById("restText");
const autosaveText = document.getElementById("autosaveText");

const recapInGame = document.getElementById("recapInGame");
const finalRecap = document.getElementById("finalRecap");

const finishPlayerCountEl = document.getElementById("finishPlayerCount");
const finishCourtWrap = document.getElementById("finishCourtWrap");
const finishCourtCountEl = document.getElementById("finishCourtCount");
const finishGameModeEl = document.getElementById("finishGameMode");
const finishMaxPointsEl = document.getElementById("finishMaxPoints");

/* Saves UI */
const saveSelect = document.getElementById("saveSelect");
const saveHint = document.getElementById("saveHint");
const saveCountBadge = document.getElementById("saveCountBadge");

/* -------------------- HELPERS -------------------- */
function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
function now(){ return Date.now(); }
function fmtDate(ts){
  try{ return new Date(ts).toLocaleString(); }catch(e){ return ""; }
}
function makeId(){
  return String(Date.now()) + "-" + Math.random().toString(16).slice(2,10);
}
function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

function readActiveSaveId(){
  try{
    const id = localStorage.getItem(ACTIVE_SAVE_KEY);
    return id || null;
  }catch(e){ return null; }
}
function writeActiveSaveId(id){
  try{
    if(!id) localStorage.removeItem(ACTIVE_SAVE_KEY);
    else localStorage.setItem(ACTIVE_SAVE_KEY, id);
  }catch(e){}
}

/* -------------------- Saves (Index) -------------------- */
function getSavesIndex(){
  try{
    const raw = localStorage.getItem(SAVES_INDEX_KEY);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function setSavesIndex(arr){
  try{ localStorage.setItem(SAVES_INDEX_KEY, JSON.stringify(arr)); }catch(e){}
}
function upsertSaveMeta(meta){
  const arr = getSavesIndex();
  const i = arr.findIndex(x=>x.id === meta.id);
  if(i >= 0) arr[i] = meta;
  else arr.unshift(meta);
  arr.sort((a,b)=>(b.savedAt||0)-(a.savedAt||0));
  setSavesIndex(arr);
}
function deleteSaveById(id){
  try{ localStorage.removeItem(SAVE_PREFIX + id); }catch(e){}
  const arr = getSavesIndex().filter(x=>x.id !== id);
  setSavesIndex(arr);

  // si on supprime la sauvegarde active, on la vide
  if(state.activeSaveId === id){
    state.activeSaveId = null;
    writeActiveSaveId(null);
  }
}

/* -------------------- Save/Load State -------------------- */
function canSaveCurrent(){
  return state && Array.isArray(state.players) && state.players.length > 0
      && Array.isArray(state.schedule) && state.schedule.length > 0;
}
function buildMetaFromState(name, id){
  const total = (state.schedule||[]).length || state.totalRounds || 0;
  const idx = Math.min((state.matchIndex||0) + 1, total);
  return { id, name, savedAt: now(), n: state.n, courts: state.courts, round: idx, total };
}

function saveToSlot(id, name){
  if(!canSaveCurrent()){
    alert("‚ÑπÔ∏è Rien √† sauvegarder pour l‚Äôinstant. D√©marre un tournoi d‚Äôabord.");
    return false;
  }
  try{
    state.savedAt = now();
    const payload = deepClone(state);
    localStorage.setItem(SAVE_PREFIX + id, JSON.stringify(payload));
    upsertSaveMeta(buildMetaFromState(name, id));

    // ‚úÖ devient la sauvegarde active
    state.activeSaveId = id;
    writeActiveSaveId(id);
    return true;
  }catch(e){
    alert("‚ùå Impossible de sauvegarder (stockage plein ?).");
    return false;
  }
}

function loadFromSlot(id){
  try{
    const raw = localStorage.getItem(SAVE_PREFIX + id);
    if(!raw) return false;
    const s = JSON.parse(raw);
    if(!s || !s.players || !s.schedule) return false;
    state = s;

    // garde-fous
    if(!Array.isArray(state.courtScores)) state.courtScores = [];
    if(!Array.isArray(state.results)) state.results = [];
    if(!Array.isArray(state.validatedCourts)) state.validatedCourts = [];
    if(!Array.isArray(state.history)) state.history = [];
    if(!state.mode) state.mode = "americano";
    if(!state.ladderOpp) state.ladderOpp = null;

    // ‚úÖ restore/force active save id
    state.activeSaveId = id;
    writeActiveSaveId(id);

    return true;
  }catch(e){ return false; }
}

/* -------------------- Auto-save rapide -------------------- */
function writeAutoSave(){
  try{
    if(!canSaveCurrent()) return;
    const payload = deepClone(state);
    payload._autosaveAt = now();
    localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(payload));
    autosaveText.textContent = `üü¢ Auto-save : ${fmtDate(payload._autosaveAt)}`;
  }catch(e){}
}
function tryLoadAutoSave(){
  try{
    const raw = localStorage.getItem(AUTOSAVE_KEY);
    if(!raw) return false;
    const s = JSON.parse(raw);
    if(!s || !s.players || !s.schedule) return false;

    state = s;
    if(!Array.isArray(state.courtScores)) state.courtScores = [];
    if(!Array.isArray(state.results)) state.results = [];
    if(!state.mode) state.mode = "americano";
    if(!state.ladderOpp) state.ladderOpp = null;

    // ‚úÖ on ne force pas une sauvegarde active sur un autosave,
    // mais on peut restaurer si elle existait
    state.activeSaveId = readActiveSaveId();

    return true;
  }catch(e){ return false; }
}

/* -------------------- UI : Multi-saves -------------------- */
function refreshSavesUI(){
  const arr = getSavesIndex();
  saveCountBadge.textContent = String(arr.length);

  saveSelect.innerHTML = "";
  if(arr.length === 0){
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "Aucune sauvegarde";
    saveSelect.appendChild(opt);
    saveSelect.disabled = true;
    saveHint.textContent = "Tu peux sauvegarder avec ¬´ üíæ Sauver ¬ª.";
    return;
  }

  saveSelect.disabled = false;
  for(const s of arr){
    const opt = document.createElement("option");
    opt.value = s.id;
    const info = `${s.n}J ‚Ä¢ ${s.courts}T ‚Ä¢ round ${s.round}/${s.total} ‚Ä¢ ${fmtDate(s.savedAt)}`;
    opt.textContent = `${s.name} ‚Äî ${info}`;
    saveSelect.appendChild(opt);
  }

  // pr√©-selection: sauvegarde active si possible
  if(state.activeSaveId && arr.some(x=>x.id === state.activeSaveId)){
    saveSelect.value = state.activeSaveId;
    saveHint.textContent = "La sauvegarde s√©lectionn√©e est la sauvegarde active.";
  }else{
    saveHint.textContent = "Choisis une sauvegarde puis Charge/Supprime.";
  }
}

function openLoadDialog(){
  refreshSavesUI();
  showSetup();
  setTimeout(()=>{ saveSelect?.scrollIntoView({behavior:"smooth", block:"center"}); }, 50);
}

function loadSelectedSave(){
  const id = saveSelect.value;
  if(!id){ alert("Aucune sauvegarde √† charger."); return; }
  if(!loadFromSlot(id)){
    alert("‚ùå Sauvegarde introuvable ou corrompue.");
    refreshSavesUI();
    return;
  }

  if(state.matchIndex >= (state.totalRounds || (state.schedule||[]).length)){
    renderFinishTable();
    showFinish();
  }else{
    showGame();
    renderMatch();
    renderRanking();
    renderRecapInGame();
    writeAutoSave();
  }
  refreshSavesUI();
}

function deleteSelectedSave(){
  const id = saveSelect.value;
  if(!id){ alert("Aucune sauvegarde √† supprimer."); return; }
  const arr = getSavesIndex();
  const meta = arr.find(x=>x.id === id);
  const label = meta ? `"${meta.name}"` : "cette sauvegarde";
  if(!confirm(`Supprimer ${label} ?`)) return;
  deleteSaveById(id);
  refreshSavesUI();
}

/* ‚úÖ IMPORTANT: Sauver = √©crase la sauvegarde active */
function manualSaveAs(){
  if(!canSaveCurrent()){
    alert("‚ÑπÔ∏è Rien √† sauvegarder pour l‚Äôinstant. D√©marre un tournoi d‚Äôabord.");
    return;
  }

  const arr = getSavesIndex();

  // 1) si on a une sauvegarde active -> on √©crase, sans demander
  if(state.activeSaveId){
    const meta = arr.find(x=>x.id === state.activeSaveId);
    const name = meta?.name || "Tournoi";
    if(saveToSlot(state.activeSaveId, name)){
      refreshSavesUI();
      autosaveText.textContent = `‚úÖ Sauvegarde mise √† jour : ${name} (${fmtDate(now())})`;
    }
    return;
  }

  // 2) sinon: premi√®re sauvegarde -> demander un nom UNE FOIS
  const defaultName = `Tournoi ${fmtDate(now())}`;
  const name = (prompt("Nom de la sauvegarde :", defaultName) || "").trim();
  if(!name) return;

  const id = makeId();
  if(saveToSlot(id, name)){
    refreshSavesUI();
    autosaveText.textContent = `‚úÖ Sauvegard√© : ${name} (${fmtDate(now())})`;
  }
}

/* -------------------- UI SETUP -------------------- */
function createInputs(){
  playersDiv.innerHTML = "";
  const n = +playerCountEl.value;
  for(let i=0;i<n;i++){
    playersDiv.innerHTML += `<input placeholder="Joueur ${i+1}" id="p${i}">`;
  }
}

function maxCourtsForN(n){
  if(n === 4) return 1;
  if(n === 6) return 1;
  if(n === 8) return 2;
  if(n === 12) return 3;
  if(n === 16) return 4;
  return 1;
}

function fillCourtOptions(selectEl, n, selected){
  const max = maxCourtsForN(n);
  selectEl.innerHTML = "";
  for(let c=max; c>=1; c--){
    const opt = document.createElement("option");
    opt.value = String(c);
    opt.textContent = `${c} terrain${c>1?"s":""}`;
    selectEl.appendChild(opt);
  }
  selectEl.value = String(selected || max);
}

function updateCourtChoiceUI(){
  const n = +playerCountEl.value;
  const max = maxCourtsForN(n);
  const show = (max > 1);
  courtWrap.style.display = show ? "block" : "none";
  if(show) fillCourtOptions(courtCountEl, n, +courtCountEl.value || max);
}

function updateFinishCourtUI(){
  const n = +finishPlayerCountEl.value;
  const max = maxCourtsForN(n);
  const show = (max > 1);
  finishCourtWrap.style.display = show ? "block" : "none";
  if(show) fillCourtOptions(finishCourtCountEl, n, +finishCourtCountEl.value || max);
}

playerCountEl.addEventListener("change", ()=>{
  createInputs();
  updateCourtChoiceUI();
});
finishPlayerCountEl.addEventListener("change", updateFinishCourtUI);

/* -------------------- Ranking helpers -------------------- */
function scoreOptions(){
  let s="";
  for(let i=0;i<=state.maxPoints;i++) s += `<option value="${i}">${i}</option>`;
  return s;
}
function playerName(i){ return state.players[i].name; }
function sortPlayersForRanking(arr){
  return [...arr].sort((a,b)=>{
    const da = a.plus - a.minus;
    const db = b.plus - b.minus;
    if(b.v !== a.v) return b.v - a.v;
    if(db !== da) return db - da;
    return b.plus - a.plus;
  });
}

/* -------------------- Scheduling: Americano (rotation) -------------------- */
function buildScheduleAmericano(n, courtsChosen){
  if(![4,6,8,12,16].includes(n)) return [];

  const maxCourts = Math.floor(n / 4) || 1;
  const courtsUsed = Math.max(1, Math.min(courtsChosen || maxCourts, maxCourts));
  const activePerRound = Math.min(n, courtsUsed * 4);
  const restCount = n - activePerRound;

  const partner = Array.from({length:n}, ()=>Array(n).fill(0));
  const against = Array.from({length:n}, ()=>Array(n).fill(0));
  const rests = Array(n).fill(0);

  const rounds = [];
  const totalRounds = n - 1;

  function incPartner(a,b){ partner[a][b]++; partner[b][a]++; }
  function incAgainst(teamA, teamB){
    for(const a of teamA) for(const b of teamB){ against[a][b]++; against[b][a]++; }
  }

  function pickRestPlayers(){
    const idx = [...Array(n).keys()];
    idx.sort((i,j)=>{
      if(rests[i] !== rests[j]) return rests[i]-rests[j];
      return (Math.random() - 0.5);
    });
    const rest = idx.slice(0, restCount);
    for(const r of rest) rests[r]++;
    return rest;
  }

  function scorePair(a,b){
    if(a === b) return 1e9;
    return partner[a][b] * 100 + (Math.random()*0.01);
  }

  function scoreMatch(teamA, teamB){
    let s = 0;
    for(const a of teamA) for(const b of teamB){ s += against[a][b] * 10; }
    return s + (Math.random()*0.01);
  }

  function makeTeams(activePlayers){
    const remaining = new Set(activePlayers);
    const pairs = [];

    while(remaining.size > 0){
      const arr = [...remaining];
      const p = arr[0];

      let bestQ = null;
      let bestScore = 1e18;

      for(const q of arr){
        if(q === p) continue;
        const sc = scorePair(p,q);
        if(sc < bestScore){
          bestScore = sc;
          bestQ = q;
        }
      }

      const q = (bestQ === null) ? arr[1] : bestQ;
      pairs.push([p,q]);
      remaining.delete(p); remaining.delete(q);
    }

    const pairIdx = [...Array(pairs.length).keys()];
    const unused = new Set(pairIdx);
    const matches = [];

    while(unused.size > 0){
      const pIdx = [...unused][0];
      unused.delete(pIdx);

      let bestOpp = null;
      let bestScore = 1e18;

      for(const oIdx of unused){
        const sc = scoreMatch(pairs[pIdx], pairs[oIdx]);
        if(sc < bestScore){
          bestScore = sc;
          bestOpp = oIdx;
        }
      }

      const oIdx = (bestOpp === null) ? [...unused][0] : bestOpp;
      unused.delete(oIdx);
      matches.push({teamA:pairs[pIdx], teamB:pairs[oIdx]});
    }

    return matches;
  }

  for(let r=0; r<totalRounds; r++){
    const rest = restCount > 0 ? pickRestPlayers() : [];
    const active = [...Array(n).keys()].filter(i => !rest.includes(i));

    if(active.length % 2 !== 0){
      rest.push(active.pop());
    }

    const matches = makeTeams(active);
    const courts = matches.slice(0, courtsUsed).map(m=>({teamA:m.teamA, teamB:m.teamB}));

    for(const c of courts){
      incPartner(c.teamA[0], c.teamA[1]);
      incPartner(c.teamB[0], c.teamB[1]);
      incAgainst(c.teamA, c.teamB);
    }

    rounds.push({ rest, courts });
  }

  return rounds;
}
/* -------------------- Scheduling: Ladder (Mont√©e/Descente) -------------------- */
function buildFirstRoundLadder(n, courts){
  const idx = [...Array(n).keys()];

  // shuffle joueurs
  for(let i=idx.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [idx[i], idx[j]] = [idx[j], idx[i]];
  }

  // cr√©er √©quipes initiales
  const teams = [];
  for(let t=0;t<courts*2;t++){
    teams.push([idx[2*t], idx[2*t+1]]);
  }

  // assigner aux terrains
  const roundCourts = [];
  for(let c=0;c<courts;c++){
    roundCourts.push({
      teamA: teams[2*c],
      teamB: teams[2*c+1]
    });
  }

  return { rest: [], courts: roundCourts };
}

/* ‚úÖ OppScore: √©vite de rejouer contre les m√™mes adversaires */
function ladderOppScore(teamA, teamB){
  if(!state.ladderOpp) return 0;
  let score = 0;

  for(const a of teamA){
    for(const b of teamB){
      score += state.ladderOpp[a][b] || 0;
    }
  }
  return score;
}

/* ‚úÖ Next round Ladder : gagnants montent, perdants descendent
   ‚úÖ √©quipes se s√©parent automatiquement */
function buildNextRoundLadder(prevRoundCourts, prevResults){

  const courtsN = prevRoundCourts.length;
  const last = courtsN - 1;

  // moved[courtIndex] = teams envoy√©es sur ce terrain
  const moved = Array.from({length:courtsN}, ()=>[]);

  for(let i=0;i<courtsN;i++){
    const court = prevRoundCourts[i];
    const res = prevResults?.[i];

    if(!res){
      moved[i].push(court.teamA, court.teamB);
      continue;
    }

    const winner = (res.a > res.b) ? court.teamA : court.teamB;
    const loser  = (res.a > res.b) ? court.teamB : court.teamA;

    // gagnant monte
    moved[Math.max(0, i-1)].push(winner);

    // perdant descend
    moved[Math.min(last, i+1)].push(loser);
  }

  const newCourts = [];

  for(let c=0;c<courtsN;c++){

    // 2 √©quipes attendues sur le terrain
    const t1 = moved[c][0] || prevRoundCourts[c].teamA;
    const t2 = moved[c][1] || prevRoundCourts[c].teamB;

    // ‚úÖ casser les partenaires : recomposition crois√©e
    const opt1A = [t1[0], t2[0]];
    const opt1B = [t1[1], t2[1]];

    const opt2A = [t1[0], t2[1]];
    const opt2B = [t1[1], t2[0]];

    // ‚úÖ choisir la recompo avec moins de re-adversaires
    const s1 = ladderOppScore(opt1A, opt1B);
    const s2 = ladderOppScore(opt2A, opt2B);

    let teamA, teamB;

    if(s1 < s2){
      teamA = opt1A; teamB = opt1B;
    }else if(s2 < s1){
      teamA = opt2A; teamB = opt2B;
    }else{
      // √©galit√© ‚Üí hasard
      if(Math.random() < 0.5){
        teamA = opt1A; teamB = opt1B;
      }else{
        teamA = opt2A; teamB = opt2B;
      }
    }

    newCourts.push({ teamA, teamB });
  }

  return { rest: [], courts: newCourts };
}

/* -------------------- NAV / SCREENS -------------------- */
function showSetup(){
  gameEl.classList.add("hidden");
  finishEl.classList.add("hidden");
  setupEl.classList.remove("hidden");
  window.scrollTo(0,0);
}
function showGame(){
  setupEl.classList.add("hidden");
  finishEl.classList.add("hidden");
  gameEl.classList.remove("hidden");
  window.scrollTo(0,0);
}
function showFinish(){
  gameEl.classList.add("hidden");
  setupEl.classList.add("hidden");
  finishEl.classList.remove("hidden");
  window.scrollTo(0,0);
}

function goToSetup(keepProgress){
  if(keepProgress) state.savedAt = now();

  playerCountEl.value = String(state.n || 4);
  createInputs();
  updateCourtChoiceUI();

  if(state.players.length){
    for(let i=0;i<state.players.length;i++){
      const inp = document.getElementById("p"+i);
      if(inp) inp.value = state.players[i].name;
    }
  }

  gameModeEl.value = state.mode;
  maxPointsEl.value = state.maxPoints;

  refreshSavesUI();
  showSetup();
}

/* -------------------- Scores (total obligatoire) -------------------- */
function onScoreChange(courtIndex, side){
  const sa = document.getElementById(`scoreA_${courtIndex}`);
  const sb = document.getElementById(`scoreB_${courtIndex}`);
  if(!sa || !sb) return;

  const total = state.maxPoints;

  let a = +sa.value;
  let b = +sb.value;

  if(side === "A"){
    a = clamp(a, 0, total);
    b = total - a;
    sb.value = b;
  }else{
    b = clamp(b, 0, total);
    a = total - b;
    sa.value = a;
  }

  if(!state.courtScores[courtIndex])
    state.courtScores[courtIndex] = {a:0,b:0};

  state.courtScores[courtIndex].a = a;
  state.courtScores[courtIndex].b = b;
}

/* -------------------- START TOURNAMENT -------------------- */
function startNewTournament(){

  state.mode = gameModeEl.value;
  state.n = +playerCountEl.value;

  const maxC = maxCourtsForN(state.n);
  state.courts = (maxC > 1) ? (+courtCountEl.value || maxC) : 1;

  state.maxPoints = clamp(+maxPointsEl.value || 21, 1, 31);

  // joueurs
  state.players = [];
  for(let i=0;i<state.n;i++){
    const name = (document.getElementById("p"+i).value || ("J"+(i+1))).trim();
    state.players.push({ name, mj:0, v:0, plus:0, minus:0 });
  }

  state.totalRounds = state.n - 1;

  // init ladderOpp
  state.ladderOpp = (state.mode === "ladder")
    ? Array.from({length: state.n}, ()=>Array(state.n).fill(0))
    : null;

  // schedule
  if(state.mode === "ladder"){
    if(state.n !== state.courts * 4){
      alert("‚ùå Ladder n√©cessite exactement 4 joueurs par terrain (pas de repos).");
      return;
    }
    state.schedule = [buildFirstRoundLadder(state.n, state.courts)];
  }else{
    state.schedule = buildScheduleAmericano(state.n, state.courts);
  }

  // reset match
  state.matchIndex = 0;
  state.validatedCourts = [];
  state.courtScores = [];
  state.results = [];
  state.history = [];

  recapInGame.classList.add("hidden");
  recapInGame.innerHTML = "";

  showGame();
  renderMatch();
  renderRanking();
  writeAutoSave();
}

/* -------------------- RESULTS STORAGE -------------------- */
function ensureRoundResults(){
  if(!state.results[state.matchIndex])
    state.results[state.matchIndex] = [];
}

/* -------------------- MATCH DISPLAY -------------------- */
function renderMatch(){

  if(state.matchIndex >= state.totalRounds){
    renderFinishTable();
    showFinish();
    return;
  }

  // ladder : g√©n√©rer le round suivant si manquant
  if(state.mode === "ladder" && !state.schedule[state.matchIndex]){
    const prev = state.schedule[state.matchIndex-1];
    const prevRes = state.results[state.matchIndex-1];
    state.schedule[state.matchIndex] =
      buildNextRoundLadder(prev.courts, prevRes);
  }

  const match = state.schedule[state.matchIndex];

  progressText.innerHTML =
    `<span class="badge">Round ${state.matchIndex+1}/${state.totalRounds}</span>
     <span class="badge">${state.mode}</span>
     <span class="badge">${state.maxPoints} pts total</span>`;

  restText.innerHTML = match.rest.length
    ? "Repos : " + match.rest.map(i=>playerName(i)).join(", ")
    : "";

  // init validated + scores m√©moire
  if(state.validatedCourts.length !== match.courts.length)
    state.validatedCourts = Array(match.courts.length).fill(false);

  if(state.courtScores.length !== match.courts.length)
    state.courtScores = Array(match.courts.length)
      .fill(null).map(()=>({a:0,b:state.maxPoints}));

  courtsDiv.innerHTML = "";

  match.courts.forEach((c, idx)=>{

    const disabled = state.validatedCourts[idx];

    courtsDiv.innerHTML += `
    <div class="card">
      <b>Terrain ${idx+1}</b><br><br>

      ${playerName(c.teamA[0])} / ${playerName(c.teamA[1])}
      vs
      ${playerName(c.teamB[0])} / ${playerName(c.teamB[1])}

      <div class="row" style="margin-top:10px;">
        <div>
          <select id="scoreA_${idx}" ${disabled?"disabled":""}
            onchange="onScoreChange(${idx},'A')">
            ${scoreOptions()}
          </select>
        </div>
        <div>
          <select id="scoreB_${idx}" ${disabled?"disabled":""}
            onchange="onScoreChange(${idx},'B')">
            ${scoreOptions()}
          </select>
        </div>
      </div>

      <button onclick="validateCourt(${idx})"
        ${disabled?"disabled":""}>
        Valider
      </button>

      <div id="ladderArrows_${idx}" class="ladderArrows"></div>
    </div>
    `;
  });

  // restore scores
  match.courts.forEach((_, idx)=>{
    document.getElementById(`scoreA_${idx}`).value = state.courtScores[idx].a;
    document.getElementById(`scoreB_${idx}`).value = state.courtScores[idx].b;
  });

  nextBtn.disabled = !state.validatedCourts.every(Boolean);
  undoBtn.disabled = state.history.length === 0;
}
/* -------------------- Validation / Undo / Next -------------------- */
function validateCourt(courtIndex){
  if(state.validatedCourts[courtIndex]) return;

  const match = state.schedule[state.matchIndex];
  const court = match.courts[courtIndex];

  // snapshot undo
  state.history.push(deepClone({
    players: state.players,
    matchIndex: state.matchIndex,
    validatedCourts: state.validatedCourts,
    courtScores: state.courtScores,
    results: state.results,
    schedule: state.schedule,
    ladderOpp: state.ladderOpp
  }));

  const a = +document.getElementById(`scoreA_${courtIndex}`).value;
  const b = +document.getElementById(`scoreB_${courtIndex}`).value;

  // m√©moriser scores
  state.courtScores[courtIndex] = {a,b};

  // validation somme + pas d'√©galit√©
  if(a + b !== state.maxPoints){
    alert(`‚ùå Score invalide : la somme doit faire ${state.maxPoints}.`);
    state.history.pop();
    return;
  }
  if(a === b){
    alert("‚ùå Score invalide : √©galit√© interdite.");
    state.history.pop();
    return;
  }

  applyResult(court.teamA, court.teamB, a, b);

  // store results recap
  ensureRoundResults();
  state.results[state.matchIndex][courtIndex] = {a,b};

  // ladder opp memory + fl√®ches
  if(state.mode === "ladder"){
    if(!state.ladderOpp){
      state.ladderOpp = Array.from({length: state.n}, ()=>Array(state.n).fill(0));
    }

    const winnerTeam = (a > b) ? court.teamA : court.teamB;
    const loserTeam  = (a > b) ? court.teamB : court.teamA;

    // incr opposition winner vs loser
    for(const x of winnerTeam){
      for(const y of loserTeam){
        state.ladderOpp[x][y] = (state.ladderOpp[x][y]||0) + 1;
        state.ladderOpp[y][x] = (state.ladderOpp[y][x]||0) + 1;
      }
    }

    const el = document.getElementById(`ladderArrows_${courtIndex}`);
    if(el){
      el.innerHTML =
        `<span class="up">‚Üë</span> ${playerName(winnerTeam[0])}/${playerName(winnerTeam[1])}
         &nbsp;&nbsp;
         <span class="down">‚Üì</span> ${playerName(loserTeam[0])}/${playerName(loserTeam[1])}`;
    }
  }

  state.validatedCourts[courtIndex] = true;

  writeAutoSave();
  renderRanking();
  renderMatch();
  renderRecapInGame();

  // activer "round suivant" si tout valid√©
  nextBtn.disabled = !state.validatedCourts.every(Boolean);

  // ‚úÖ autosave + sauvegarde manuelle "en cours" (si activ√©e)
  if(state._currentSaveId){
    // √©crase silencieusement la sauvegarde courante
    saveToSlot(state._currentSaveId, state._currentSaveName || "Tournoi");
  }
}

function applyResult(teamA, teamB, scoreA, scoreB){
  for(const p of teamA){
    state.players[p].mj++;
    state.players[p].plus += scoreA;
    state.players[p].minus += scoreB;
  }
  for(const p of teamB){
    state.players[p].mj++;
    state.players[p].plus += scoreB;
    state.players[p].minus += scoreA;
  }
  if(scoreA > scoreB){
    for(const p of teamA) state.players[p].v++;
  }else{
    for(const p of teamB) state.players[p].v++;
  }
}

function nextMatch(){
  if(!state.validatedCourts.every(Boolean)) return;

  // ladder: g√©n√©rer le prochain round maintenant
  if(state.mode === "ladder" && state.matchIndex + 1 < state.totalRounds){
    const cur = state.schedule[state.matchIndex];
    const curRes = state.results?.[state.matchIndex];
    state.schedule[state.matchIndex + 1] = buildNextRoundLadder(cur.courts, curRes);
  }

  state.matchIndex++;
  state.validatedCourts = [];
  state.courtScores = [];
  writeAutoSave();

  renderMatch();
  renderRecapInGame();

  // ‚úÖ √©crase la sauvegarde en cours (si activ√©e)
  if(state._currentSaveId){
    saveToSlot(state._currentSaveId, state._currentSaveName || "Tournoi");
  }
}

function undoLast(){
  if(!state.history.length) return;
  const prev = state.history.pop();

  state.players = prev.players;
  state.matchIndex = prev.matchIndex;
  state.validatedCourts = prev.validatedCourts;
  state.courtScores = prev.courtScores || [];
  state.results = prev.results || [];
  state.schedule = prev.schedule || state.schedule;
  state.ladderOpp = prev.ladderOpp || state.ladderOpp;

  writeAutoSave();
  renderRanking();
  renderMatch();
  renderRecapInGame();

  // ‚úÖ √©crase la sauvegarde en cours (si activ√©e)
  if(state._currentSaveId){
    saveToSlot(state._currentSaveId, state._currentSaveName || "Tournoi");
  }
}

/* -------------------- Ranking -------------------- */
function renderRanking(){
  rankingBody.innerHTML = "";
  const sorted = sortPlayersForRanking(state.players);

  for(const p of sorted){
    rankingBody.innerHTML += `
      <tr>
        <td>${p.name}</td>
        <td>${p.mj}</td>
        <td>${p.v}</td>
        <td>${p.plus}</td>
        <td>${p.minus}</td>
        <td>${p.plus - p.minus}</td>
      </tr>
    `;
  }
}

/* -------------------- Recap -------------------- */
function formatTeam(team){
  return `${playerName(team[0])}/${playerName(team[1])}`;
}

function renderRecap(targetEl, includeAll){
  const maxRound = includeAll ? (state.results?.length || 0) : (state.matchIndex + 1);
  let html = "";

  for(let r=0; r<maxRound; r++){
    const round = state.schedule[r];
    if(!round) continue;

    const resArr = state.results?.[r] || [];
    const courts = round.courts || [];

    for(let c=0;c<courts.length;c++){
      const court = courts[c];
      const res = resArr[c];
      if(!res) continue;

      html += `
        <div class="recapLine">
          <div class="recapLeft">
            <b>R${r+1}</b> ‚Ä¢ T${c+1} ‚Äî
            ${formatTeam(court.teamA)} <b>${res.a}-${res.b}</b> ${formatTeam(court.teamB)}
          </div>
          <div class="recapRight">${state.mode==="ladder" ? "‚Üë‚Üì" : "üéæ"}</div>
        </div>
      `;
    }
  }

  targetEl.innerHTML = html || `<div class="small">Pas encore de match valid√©.</div>`;
}

function toggleRecap(){
  recapInGame.classList.toggle("hidden");
  if(!recapInGame.classList.contains("hidden")){
    renderRecapInGame();
  }
}

function renderRecapInGame(){
  if(recapInGame.classList.contains("hidden")) return;
  renderRecap(recapInGame, false);
}

/* -------------------- Finish -------------------- */
function renderFinishTable(){
  // sync finish settings
  finishPlayerCountEl.value = String(state.n || 4);
  updateFinishCourtUI();
  if(finishCourtWrap.style.display !== "none"){
    fillCourtOptions(finishCourtCountEl, state.n, state.courts || maxCourtsForN(state.n));
  }
  finishGameModeEl.value = state.mode || "americano";
  finishMaxPointsEl.value = String(state.maxPoints || 21);

  const sorted = sortPlayersForRanking(state.players);
  finalRankingBody.innerHTML = "";
  sorted.forEach((p, i)=>{
    finalRankingBody.innerHTML += `
      <tr>
        <td>${i+1}</td>
        <td>${p.name}</td>
        <td>${p.mj}</td>
        <td>${p.v}</td>
        <td>${p.plus}</td>
        <td>${p.minus}</td>
        <td>${p.plus - p.minus}</td>
      </tr>
    `;
  });

  renderRecap(finalRecap, true);
}

/* -------------------- Restart -------------------- */
function restartSamePlayers(){
  const n = state.n;
  const courts = state.courts;
  const names = state.players.map(p=>p.name);
  const mode = state.mode;
  const maxPoints = state.maxPoints;

  state.mode = mode;
  state.n = n;
  state.courts = courts;
  state.maxPoints = maxPoints;
  state.totalRounds = n - 1;

  state.players = names.map(name=>({name, mj:0, v:0, plus:0, minus:0}));

  state.ladderOpp = (mode === "ladder")
    ? Array.from({length:n}, ()=>Array(n).fill(0))
    : null;

  if(mode === "ladder"){
    if(n !== courts*4){
      alert("‚ùå Mont√©e/Descente n√©cessite 4√óterrains joueurs.");
      return;
    }
    state.schedule = [buildFirstRoundLadder(n, courts)];
  }else{
    state.schedule = buildScheduleAmericano(n, courts);
  }

  state.matchIndex = 0;
  state.validatedCourts = [];
  state.courtScores = [];
  state.results = [];
  state.history = [];

  recapInGame.classList.add("hidden");
  recapInGame.innerHTML = "";

  showGame();
  renderMatch();
  renderRanking();
  writeAutoSave();

  // ‚úÖ √©crase sauvegarde en cours (si activ√©e)
  if(state._currentSaveId){
    saveToSlot(state._currentSaveId, state._currentSaveName || "Tournoi");
  }
}

/* -------------------- New game choose players -------------------- */
function newGameChoosePlayers(){
  const n = +finishPlayerCountEl.value;
  const max = maxCourtsForN(n);
  const courts = (max > 1) ? (+finishCourtCountEl.value || max) : 1;

  playerCountEl.value = String(n);
  createInputs();
  updateCourtChoiceUI();
  if(courtWrap.style.display !== "none"){
    fillCourtOptions(courtCountEl, n, courts);
  }

  gameModeEl.value = finishGameModeEl.value;
  maxPointsEl.value = String(clamp(+finishMaxPointsEl.value || 21, 1, 31));

  // reset state complet
  state = {
    mode: gameModeEl.value,
    n,
    courts,
    maxPoints: clamp(+maxPointsEl.value || 21, 1, 31),
    totalRounds: n - 1,

    players: [],
    schedule: [],
    matchIndex: 0,

    validatedCourts: [],
    courtScores: [],
    results: [],

    history: [],
    savedAt: null,
    ladderOpp: (gameModeEl.value === "ladder")
      ? Array.from({length:n}, ()=>Array(n).fill(0))
      : null,

    // ‚úÖ NEW: sauvegarde manuelle "en cours" (√©crasement)
    _currentSaveId: null,
    _currentSaveName: null
  };

  refreshSavesUI();
  showSetup();
}

/* -------------------- Reset all -------------------- */
function resetAll(){
  if(!confirm("Tout effacer (application + sauvegardes) ?")) return;

  const arr = getSavesIndex();
  for(const s of arr){
    try{ localStorage.removeItem(SAVE_PREFIX + s.id); }catch(e){}
  }
  try{ localStorage.removeItem(SAVES_INDEX_KEY); }catch(e){}
  try{ localStorage.removeItem(AUTOSAVE_KEY); }catch(e){}

  location.reload();
}

/* -------------------- ‚úÖ MODIF IMPORTANT : Sauvegarde manuelle = √©crase la sauvegarde en cours -------------------- */
/* Remplace le comportement: on ne demande pas √† chaque fois un nouveau nom.
   - 1√®re fois: on demande un nom et on cr√©e une sauvegarde "courante"
   - fois suivantes: on √©crase automatiquement cette m√™me sauvegarde
*/
(function patchManualSaveOverwrite(){
  // on garde l'ancienne fonction si elle existe
  const oldManualSaveAs = window.manualSaveAs;

  window.manualSaveAs = function(){
    if(!canSaveCurrent()){
      alert("‚ÑπÔ∏è Rien √† sauvegarder pour l‚Äôinstant. D√©marre un tournoi d‚Äôabord.");
      return;
    }

    // si d√©j√† une sauvegarde "courante": √©crase directement
    if(state._currentSaveId){
      const ok = saveToSlot(state._currentSaveId, state._currentSaveName || "Tournoi");
      if(ok) autosaveText.textContent = `‚úÖ Sauvegard√© (√©cras√©) : ${state._currentSaveName || "Tournoi"} ‚Äî ${fmtDate(now())}`;
      refreshSavesUI();
      return;
    }

    // sinon: 1√®re sauvegarde -> demande un nom UNE SEULE FOIS
    const defaultName = `Tournoi ${fmtDate(now())}`;
    const name = (prompt("Nom de la sauvegarde (une seule fois) :", defaultName) || "").trim();
    if(!name) return;

    const id = makeId();
    state._currentSaveId = id;
    state._currentSaveName = name;

    const ok = saveToSlot(id, name);
    if(ok){
      autosaveText.textContent = `‚úÖ Sauvegard√© : ${name} ‚Äî ${fmtDate(now())}`;
      refreshSavesUI();
    }
  };

  // init champs si manquants (compat anciennes saves)
  if(state._currentSaveId === undefined) state._currentSaveId = null;
  if(state._currentSaveName === undefined) state._currentSaveName = null;
})();

/* -------------------- INIT -------------------- */
(function init(){
  createInputs();
  updateCourtChoiceUI();
  updateFinishCourtUI();
  refreshSavesUI();
  showSetup();

  // proposer auto-save
  if(tryLoadAutoSave()){
    if(confirm("Reprendre la derni√®re partie (auto-save) ?")){
      refreshSavesUI();
      if(state.matchIndex >= (state.totalRounds || (state.schedule||[]).length)){
        renderFinishTable();
        showFinish();
      }else{
        showGame();
        renderMatch();
        renderRanking();
        renderRecapInGame();
      }
      writeAutoSave();
    }
  }
})();
</script>

</body>
</html>
